package Haskell.Analisis;
import Graphik.Ast.*;
import Interfaz.Inicio;

import java_cup.runtime.*;

parser code
{:
    /**Metodo al que se llama automáticamente ante algún error sintactico.*/
    public void syntax_error(Symbol s){
        System.out.println("Error en la Línea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador "
        +s.value + " no reconocido." );
    }

    /**Metodo al que se llama en el momento en que ya no es posible una recuperación de
    errores.*/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error en la Línea " + (s.right+1)+ "Columna "+(s.left+1)+". Identificador " +
        s.value + " no reconocido.");
    }
:}


/*terminales de simbolos reservados*/
terminal String corInicio,corFin,llaveInicio,llaveFin,dosPuntos,igual,coma,parenFin,parenInicio,salto;
terminal String puntoComa;

/*Sentencias de control*/
terminal String si,then,sino,caso,iden,end,dolar,calcular;

/*funciones propias del lenguaje*/
terminal String let,ans,succ,decc,min,max,concatenar,indice,sum,product,revers,impr;
terminal String par,asc,desc,length;

/* simbolos de operaciones aritmeticas. */
terminal String mas, menos, mul, div,mod,pot,sqrt;

/*simbolos de operaciones relacionales*/
terminal String mayor,menor,igualIgual,mayorIgual,menorIgual,noIgual;

/*simbolos de operaciones logicas*/
terminal String or,and;

/*
* Este terminal tiene un valor string. Recuerda que le dábamos el valor
* en el código del analizador léxico, al darle como parámetro un valor
* string al objeto Symbolo.
*/
/*Contiene el valor del tipo de dato especifico*/
terminal String numero,cadena,entero,caracter;

/*
* Aquí están los no terminales
*/

non terminal Nodo EXPA,EXPL,EXPR,DATO;
non terminal Nodo INICIO,CALCULAR,LISTA,VALORES;
non terminal Nodo ARRAY,ARRAY2,SENTENCIAS,SENTENCIA,EXPC;
non terminal Nodo INDICE,ACCESO,SIMPLIFICADA,TIPOSIMPLIFICADA,VALOREXP;
non terminal Nodo FUNCION,PARAMETROS,PARAMETROSTAR,LLAMADA,SI,CASO,CASOS,SELECCIONAR,VALORCASE;
non terminal Nodo SALTOS,OPERACIONLISTA,TIPOOPERACIONLISTA,OPERACIONLISTA2,TIPOOPERACIONLISTA2;
non terminal Nodo CONCA,TIPOLISTA,TIPOVALOR;

/* Precedences */
precedence left mas, menos;
precedence left mul, div,mod;
precedence left pot,sqrt;
precedence left parenInicio,parenFin;
precedence left igualIgual,mayor,menor,mayorIgual,menorIgual,noIgual;
precedence left or;
precedence left and;

precedence left sum,max,min,product,length,revers,impr,par,asc,desc;
precedence left concatenar;

/* ­­­­­­­­­­­­­­ Declaración de la gramática  ­­­­­­­­­­­ */
start with INICIO; // start with sirve para indicarle al parser con que produccion empezar

INICIO::=FUNCION
	|SENTENCIA;

//expresiones artmeticas---falta llamada metodo,aumento y decremento
EXPA::=EXPA:d1 mas:op EXPA:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPA:d1 menos:op EXPA:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPA:d1 mul:op EXPA:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPA:d1 div:op EXPA:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPA:d1 pot:op EXPA:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPA:d1 sqrt:op EXPA:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPA:d1 mod:op EXPA:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |parenInicio EXPA:d1 parenFin {:RESULT=d1;:}
    |DATO:d1 {:RESULT=d1;:}  
    |VALOREXP:val {:RESULT=val;:} 
    |iden:id1 {:RESULT=new Nodo("id",id1,id1right,id1left);:};

EXPC::=iden:id {:RESULT=new Nodo("id",id,idright,idleft);:}
	|VALOREXP:val {:RESULT=val;:};
}

EXPR::=EXPC:d1 igualIgual:op EXPC:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPC:d1 mayor:op EXPC:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPC:d1 menor:op EXPC:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPC:d1 mayorIgual:op EXPC:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPC:d1 menorIgual:op EXPC:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPC:d1 noIgual:op EXPC:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPA:d1 {:RESULT=d1;:};

EXPL::=EXPL:d1 and:op EXPL:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |EXPL:d1 or:op EXPL:d2 {:RESULT=new Nodo(op,opright,opleft);RESULT.add(d1);RESULT.add(d2);:}
    |parenInicio EXPL:d1 parenFin {:RESULT=d1;:}
    |EXPR:d1 {:RESULT=d1;:};

DATO::=numero:dato {:RESULT=new Nodo("numero",dato,datoright,datoleft);:}
    |cadena:dato {:RESULT=new Nodo("cadena",dato,datoright,datoleft);:};


SALTOS::=SALTOS salto
		|salto;

//devuelven un valor numerico
CALCULAR::=dolar calcular:cal EXPL:exp dolar{:
		RESULT=new Nodo("calcular",calright,calleft);
		RESULT.add(exp);
		:};

SIMPLIFICADA::=dolar TIPOSIMPLIFICADA CALCULAR dolar;

TIPOSIMPLIFICADA::=succ
				|decc;

VALOREXP::=SIMPLIFICADA
		|ACCESO
		|CALCULAR
		|OPERACIONLISTA;

//devuelve un valor y es operacion con listas

OPERACIONLISTA::=dolar TIPOOPERACIONLISTA TIPOLISTA dolar;


TIPOOPERACIONLISTA::=min
					|max
					|sum
					|product
					|length;


//----------------------------------------------		

//devuelve una lista y es operacion con listas
OPERACIONLISTA2::=dolar TIPOOPERACIONLISTA2 TIPOLISTA dolar;

TIPOOPERACIONLISTA2::=revers
					|impr
					|par
					|asc
					|desc;
TIPOLISTA::=iden
			|ARRAY
			|OPERACIONLISTA2
			|CONCA
			|cadena;

CONCA::=dolar TIPOLISTA concatenar TIPOLISTA dolar;

//-----------------------------------------------------
//declaracion de listas
LISTA::= dolar let iden igual TIPOLISTA dolar; 

ARRAY::=corInicio VALORES corFin
		|corInicio ARRAY2 corFin;

ARRAY2::=ARRAY2 coma ARRAY
		|ARRAY;

VALORES::=VALORES coma TIPOVALOR
		|TIPOVALOR;

TIPOVALOR::=EXPL
			|caracter;
//------------fin declaracion listas		


//acceso a listas
ACCESO::=dolar iden INDICE dolar;		

INDICE::=INDICE indice numero
		|indice numero;
//---------------fin acceso a listas

SENTENCIAS::=SENTENCIAS SALTOS SENTENCIA
			|SENTENCIA;

SENTENCIA::=CALCULAR
			|LLAMADA 
			|SI 
			|SELECCIONAR
			|LISTA
			|ACCESO
			|SIMPLIFICADA
			|OPERACIONLISTA
			|OPERACIONLISTA2
			|CONCA
			|ans;

//funcion
FUNCION::=iden:id PARAMETROSTAR:par igual SENTENCIA:sent1 SALTOS SENTENCIAS:sent2 SALTOS end SALTOS{:
		Nodo funcion=new Nodo("funcion",id,idright,idright);
		funcion.add(par);
		for(Nodo hijo : sent2.hijos){
			sent1.hijos.add(hijo);
		}
		funcion.add(sent1);
		RESULT=funcion;
		:}
		
		|iden:id PARAMETROSTAR:par igual SENTENCIA:sent1 SALTOS end SALTOS {:
			Nodo funcion=new Nodo("funcion",id,idright,idright);
			funcion.add(par);
			funcion.add(sent1);
			RESULT=funcion;
			:};

PARAMETROSTAR::=PARAMETROS:par {:RESULT=par;:}
			|;

PARAMETROS::=PARAMETROS:para coma iden:id {:RESULT=para;
			Nodo par=new Nodo("id",id,idright,idleft);
			RESULT.add(par);
			:}
			|iden:id {:RESULT=new Nodo("parametros",idright,idleft);
			Nodo par=new Nodo("id",id,idright,idleft);
			RESULT.add(par);
			:};

LLAMADA::=dolar iden llaveInicio VALORES llaveFin dolar;

SI::=si EXPL then SALTOS SENTENCIAS SALTOS sino SALTOS SENTENCIAS SALTOS end;

SELECCIONAR::= caso EXPA SALTOS CASOS  end;

CASOS::=CASOS CASO
		|CASO;

CASO::=VALORCASE dosPuntos SENTENCIAS puntoComa SALTOS;

VALORCASE::=numero
		|cadena;